<% const isRoutineMode=mode==='ROUTINE' ; const currentExercise=exercise; %>

  <!-- MediaPipe Pose CDN -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js" crossorigin="anonymous"></script>

  <!-- FitPlus AI ëª¨ë“ˆ -->
  <script src="/js/workout/pose-engine.js"></script>
  <script src="/js/workout/scoring-engine.js"></script>
  <script src="/js/workout/rep-counter.js"></script>
  <script src="/js/workout/session-buffer.js"></script>

  <div class="workout-container">
    <!-- ìƒë‹¨ í—¤ë” -->
    <header class="workout-header">
      <div class="workout-title">
        <% if (isRoutineMode && routine) { %>
          <h2>
            <%= routine.name %>
          </h2>
          <span class="muted">ë£¨í‹´ ìš´ë™</span>
          <% } else { %>
            <h2>
              <%= currentExercise.name %>
            </h2>
            <span class="muted">ììœ¨ ìš´ë™</span>
            <% } %>
      </div>

      <!-- ìƒíƒœ í‘œì‹œ -->
      <div class="status-badges">
        <span class="status preparing" id="statusBadge">ì¤€ë¹„ ì¤‘</span>
      </div>

      <div class="workout-actions">
        <button class="ghost" onclick="confirmExit()">âœ• ì¢…ë£Œ</button>
      </div>
    </header>

    <!-- ì•Œë¦¼ ì˜ì—­ -->
    <div class="alert-container" id="alertContainer" hidden>
      <div class="alert">
        <strong id="alertTitle">ìì„¸ ì•Œë¦¼</strong>
        <span id="alertMessage">ë¬´ë¦ ê°ë„ë¥¼ ë” êµ½í˜€ì£¼ì„¸ìš”</span>
      </div>
    </div>

    <div class="workout-main">
      <!-- ì¹´ë©”ë¼ ì˜ì—­ -->
      <div class="camera-section">
        <div class="camera-frame" id="cameraFrame">
          <video id="videoElement" autoplay playsinline></video>
          <canvas id="poseCanvas"></canvas>
          <div class="camera-overlay" id="cameraOverlay">
            <p>ğŸ“· ì¹´ë©”ë¼ë¥¼ ì—°ê²° ì¤‘...</p>
          </div>
        </div>

        <!-- ì¹´ë©”ë¼ ì»¨íŠ¸ë¡¤ -->
        <div class="camera-actions" id="cameraActions">
          <button class="primary" id="startBtn" onclick="startWorkout()">
            â–¶ï¸ ìš´ë™ ì‹œì‘
          </button>
        </div>
      </div>

      <!-- ì‚¬ì´ë“œ íŒ¨ë„ -->
      <aside class="workout-sidebar">
        <!-- ì‹¤ì‹œê°„ ì ìˆ˜ -->
        <div class="card score-card">
          <div class="score-header">
            <span class="muted">ì´ë²ˆ rep ì ìˆ˜</span>
            <span class="muted" id="viewInfo" style="font-size: 12px;"></span>
          </div>
          <div class="score" id="liveScore">--</div>
          <div class="score-detail" id="scoreBreakdown">
            <!-- ì ìˆ˜ ì„¸ë¶€í•­ëª©ì´ ì—¬ê¸°ì— í‘œì‹œë¨ -->
          </div>
        </div>

        <!-- ìš´ë™ ì¹´ìš´í„° -->
        <div class="card counter-card">
          <div class="counter-row">
            <div class="counter-item">
              <span class="counter-value" id="repCount">0</span>
              <span class="counter-label">íšŸìˆ˜</span>
            </div>
            <div class="counter-item">
              <span class="counter-value" id="setCount">1</span>
              <span class="counter-label">ì„¸íŠ¸</span>
            </div>
          </div>
          <% if (isRoutineMode && routine) { %>
            <div class="progress-card">
              <span class="muted">ë£¨í‹´ ì§„í–‰</span>
              <div class="progress">
                <div class="progress-bar" id="routineProgress" style="width: 0%"></div>
              </div>
              <span class="muted" id="routineStep">1 / <%= routine.routine_setup.length %> ìš´ë™</span>
            </div>
            <% } %>
        </div>

        <!-- íƒ€ì´ë¨¸ -->
        <div class="card timer-card">
          <div class="timer-display">
            <span class="timer-value" id="timerValue">00:00</span>
            <span class="timer-label" id="timerLabel">ìš´ë™ ì‹œê°„</span>
          </div>
          <div class="rest-timer" id="restTimer" hidden>
            <span class="rest-value" id="restValue">30</span>
            <span class="rest-label">íœ´ì‹ ë‚¨ìŒ</span>
          </div>
        </div>

        <!-- ì»¨íŠ¸ë¡¤ ë²„íŠ¼ -->
        <div class="control-row">
          <button class="ghost full" id="pauseBtn" onclick="togglePause()" disabled>
            â¸ï¸ ì¼ì‹œì •ì§€
          </button>
        </div>
        <div class="control-row">
          <button class="primary full" id="finishBtn" onclick="finishWorkout()" disabled>
            âœ… ìš´ë™ ì¢…ë£Œ
          </button>
        </div>
      </aside>
    </div>
  </div>

  <!-- ì¢…ë£Œ í™•ì¸ ëª¨ë‹¬ -->
  <div class="modal" id="exitModal" hidden>
    <div class="modal-content">
      <div class="modal-header">
        <h3>ìš´ë™ ì¢…ë£Œ</h3>
        <button class="icon" onclick="closeExitModal()">Ã—</button>
      </div>
      <div class="modal-body">
        <p>ì •ë§ë¡œ ìš´ë™ì„ ì¢…ë£Œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?</p>
        <p class="muted">í˜„ì¬ê¹Œì§€ì˜ ê¸°ë¡ì´ ì €ì¥ë©ë‹ˆë‹¤.</p>
      </div>
      <div class="modal-actions">
        <button class="ghost" onclick="closeExitModal()">ê³„ì†í•˜ê¸°</button>
        <button class="danger" onclick="forceExit()">ì¢…ë£Œí•˜ê¸°</button>
      </div>
    </div>
  </div>

  <script>
    // ìš´ë™ ë°ì´í„°
    const workoutData = {
      mode: '<%= mode %>',
      exercise: <%-  JSON.stringify(currentExercise) %>,
      scoringProfile: <%-  scoringProfile ? JSON.stringify(scoringProfile) : 'null' %>,
    <% if (isRoutineMode) { %>
      routine: <%-  JSON.stringify(routine) %>,
        routineInstance: <%-  JSON.stringify(routineInstance) %>,
    <% } else { %>
      routine: null,
        routineInstance: null,
    <% } %>
  };

    // AI ì—”ì§„ ì¸ìŠ¤í„´ìŠ¤
    let poseEngine = null;
    let scoringEngine = null;
    let repCounter = null;
    let sessionBuffer = null;

    // ìƒíƒœ ê´€ë¦¬
    let state = {
      phase: 'PREPARING', // PREPARING, WORKING, RESTING, PAUSED, FINISHED
      sessionId: null,
      currentSet: 1,
      currentRep: 0,
      currentStepIndex: 0,
      totalTime: 0,
      restTimeLeft: 0,
      liveScore: 0,
      isPaused: false,
      timerInterval: null,
      restInterval: null,
      alertCooldown: false,
      frameLoop: null,
      lastViewInfoAt: 0,
      lastViewInfoText: '',
      repInProgressPrev: false,
      repMetricBuffer: {},
      lastRepMetricSummary: []
    };

    // DOM ìš”ì†Œ
    const videoElement = document.getElementById('videoElement');
    const poseCanvas = document.getElementById('poseCanvas');
    const cameraOverlay = document.getElementById('cameraOverlay');
    const statusBadge = document.getElementById('statusBadge');
    const liveScoreEl = document.getElementById('liveScore');
    const scoreBreakdownEl = document.getElementById('scoreBreakdown');
    const viewInfoEl = document.getElementById('viewInfo');
    const repCountEl = document.getElementById('repCount');
    const setCountEl = document.getElementById('setCount');
    const timerValueEl = document.getElementById('timerValue');
    const timerLabelEl = document.getElementById('timerLabel');
    const restTimerEl = document.getElementById('restTimer');
    const restValueEl = document.getElementById('restValue');
    const alertContainer = document.getElementById('alertContainer');
    const alertTitle = document.getElementById('alertTitle');
    const alertMessage = document.getElementById('alertMessage');
    const startBtn = document.getElementById('startBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const finishBtn = document.getElementById('finishBtn');

    // AI ì—”ì§„ ì´ˆê¸°í™”
    async function initAIEngines() {
      try {
        cameraOverlay.innerHTML = '<p>ğŸ¤– AI ì—”ì§„ ë¡œë”© ì¤‘...</p>';

        // 1. PoseEngine ì´ˆê¸°í™”
        poseEngine = new PoseEngine();
        await poseEngine.initialize();

        // 2. ScoringEngine ì´ˆê¸°í™”
        scoringEngine = new ScoringEngine(workoutData.scoringProfile);

        // 3. RepCounter ì´ˆê¸°í™”
        repCounter = new RepCounter(workoutData.exercise.code);
        repCounter.onRepComplete = handleRepComplete;

        // 4. PoseEngine ì½œë°± ì„¤ì •
        poseEngine.onPoseDetected = handlePoseDetected;

        console.log('[Session] AI ì—”ì§„ ì´ˆê¸°í™” ì™„ë£Œ');
        return true;
      } catch (error) {
        console.error('[Session] AI ì—”ì§„ ì´ˆê¸°í™” ì‹¤íŒ¨:', error);
        cameraOverlay.innerHTML = '<p>âŒ AI ì—”ì§„ ë¡œë”© ì‹¤íŒ¨</p><p class="muted">í˜ì´ì§€ë¥¼ ìƒˆë¡œê³ ì¹¨í•´ì£¼ì„¸ìš”</p>';
        return false;
      }
    }

    // ì¹´ë©”ë¼ ì´ˆê¸°í™”
    async function initCamera() {
      try {
        cameraOverlay.innerHTML = '<p>ğŸ“· ì¹´ë©”ë¼ë¥¼ ì—°ê²° ì¤‘...</p>';

        // AI ì—”ì§„ ë¨¼ì € ì´ˆê¸°í™”
        const aiReady = await initAIEngines();
        if (!aiReady) return;

        // ì¹´ë©”ë¼ ìŠ¤íŠ¸ë¦¼ ê°€ì ¸ì˜¤ê¸°
        // const stream = await navigator.mediaDevices.getUserMedia({
        //   video: { 
        //     facingMode: 'user', 
        //     width: { ideal: 640 }, 
        //     height: { ideal: 480 } 
        //   }
        // });
        // ë””ë²„ê¹… ìš©ìœ¼ë¡œ í™”ë©´ ìº¡ì²˜ë¡œ ëŒ€ì²´
        const stream = await navigator.mediaDevices.getDisplayMedia({
          video: { width: 640, height: 480 }
        });

        videoElement.srcObject = stream;

        // ë¹„ë””ì˜¤ ë©”íƒ€ë°ì´í„° ë¡œë“œ í›„ ìº”ë²„ìŠ¤ í¬ê¸° ì„¤ì •
        videoElement.onloadedmetadata = () => {
          poseCanvas.width = videoElement.videoWidth;
          poseCanvas.height = videoElement.videoHeight;
        };

        cameraOverlay.innerHTML = '<p>âœ… ì¤€ë¹„ ì™„ë£Œ</p><p class="muted">ì „ì‹ ì´ ì˜ ë³´ì´ë„ë¡ ìœ„ì¹˜ë¥¼ ì¡°ì •í•˜ì„¸ìš”</p>';
        startBtn.disabled = false;

      } catch (error) {
        console.error('[Session] ì¹´ë©”ë¼ ì—ëŸ¬:', error);

        // ê°œë°œìš©: í™”ë©´ ìº¡ì²˜ë¡œ ëŒ€ì²´
        try {
          const stream = await navigator.mediaDevices.getDisplayMedia({
            video: { width: 640, height: 480 }
          });
          videoElement.srcObject = stream;
          videoElement.onloadedmetadata = () => {
            poseCanvas.width = videoElement.videoWidth;
            poseCanvas.height = videoElement.videoHeight;
          };
          cameraOverlay.innerHTML = '<p>âœ… í™”ë©´ ìº¡ì²˜ ëª¨ë“œ</p><p class="muted">ê°œë°œìš© ëª¨ë“œì…ë‹ˆë‹¤</p>';
          startBtn.disabled = false;
        } catch (e) {
          cameraOverlay.innerHTML = '<p>âŒ ì¹´ë©”ë¼ ì—°ê²° ì‹¤íŒ¨</p><p class="muted">ì¹´ë©”ë¼ ê¶Œí•œì„ í™•ì¸í•´ì£¼ì„¸ìš”</p>';
        }
      }
    }

    // ìš´ë™ ì‹œì‘
    async function startWorkout() {
      try {
        // ì„¸ì…˜ ìƒì„± API í˜¸ì¶œ
        const response = await fetch('/api/workout/session', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            exercise_id: workoutData.exercise.exercise_id,
            scoring_profile_id: workoutData.scoringProfile?.scoring_profile_id,
            mode: workoutData.mode,
            routine_instance_id: workoutData.routineInstance?.routine_instance_id
          })
        });

        const data = await response.json();
        if (!response.ok) throw new Error(data.error);

        state.sessionId = data.session.session_id;
        state.phase = 'WORKING';

        // SessionBuffer ì´ˆê¸°í™”
        sessionBuffer = new SessionBuffer(state.sessionId);
        sessionBuffer.addEvent('SESSION_START', { exercise: workoutData.exercise.code });

        updateStatus('running', 'ìš´ë™ ì¤‘');
        cameraOverlay.hidden = true;
        startBtn.hidden = true;
        pauseBtn.disabled = false;
        finishBtn.disabled = false;

        // íƒ€ì´ë¨¸ ì‹œì‘
        startTimer();

        // AI í¬ì¦ˆ ê°ì§€ ì‹œì‘
        startPoseDetection();

      } catch (error) {
        console.error('[Session] ì‹œì‘ ì—ëŸ¬:', error);
        alert('ìš´ë™ ì‹œì‘ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: ' + error.message);
      }
    }

    // í¬ì¦ˆ ê°ì§€ ì‹œì‘
    function startPoseDetection() {
      if (!poseEngine) return;

      poseEngine.start();

      // í”„ë ˆì„ ë£¨í”„ ì‹œì‘
      const processFrame = async () => {
        if (poseEngine && poseEngine.isRunning && !state.isPaused) {
          await poseEngine.send(videoElement);

          // ìº”ë²„ìŠ¤ì— í¬ì¦ˆ ê·¸ë¦¬ê¸°
          if (poseEngine.lastResults) {
            poseEngine.drawPose(poseCanvas, poseEngine.lastResults);
          }
        }

        if (state.phase !== 'FINISHED') {
          state.frameLoop = requestAnimationFrame(processFrame);
        }
      };

      state.frameLoop = requestAnimationFrame(processFrame);
      console.log('[Session] í¬ì¦ˆ ê°ì§€ ì‹œì‘');
    }

    // í¬ì¦ˆ ê°ì§€ ê²°ê³¼ ì²˜ë¦¬
    function handlePoseDetected(poseData) {
      if (state.phase !== 'WORKING' || state.isPaused) return;

      const { angles } = poseData;
      updateViewInfo(angles);

      // ë””ë²„ê¹…: ê°ë„ ì¶œë ¥
      // console.log('[Session] ê°ë„:', angles);

      // 1. ì ìˆ˜ ê³„ì‚°
      const scoreResult = scoringEngine.calculate(angles);

      // ë””ë²„ê¹…: ì ìˆ˜ ê²°ê³¼
      if (scoreResult.score > 0) {
        console.log('[Session] ì ìˆ˜:', scoreResult.score, 'breakdown:', scoreResult.breakdown?.length);
      }

      // 2. íšŸìˆ˜ ê°ì§€ (rep ìƒíƒœ/ì ìˆ˜ ì§‘ê³„ë¥¼ ìœ„í•´ ë¨¼ì € ì—…ë°ì´íŠ¸)
      repCounter.update(angles, scoreResult.score);

      updateRepMetricBuffer(scoreResult);

      updateScoreDisplay(scoreResult);

      // 3. ì„¸ì…˜ ë²„í¼ì— ì €ì¥
      if (sessionBuffer) {
        sessionBuffer.addScore(scoreResult);
      }

      // 4. í”¼ë“œë°± ì²´í¬
      const shouldCheckFeedback = repCounter?.pattern?.isTimeBased ? true : repCounter?.isInProgress();
      if (shouldCheckFeedback) {
        checkFeedback(scoreResult);
      }
    }

    function aggregateScores(scores) {
      if (!scores || scores.length === 0) return 0;
      const sorted = scores
        .filter(s => typeof s === 'number' && !Number.isNaN(s))
        .slice()
        .sort((a, b) => a - b);
      if (sorted.length === 0) return 0;

      const trimCount = Math.floor(sorted.length * 0.1);
      const trimmed = sorted.length >= 10 ? sorted.slice(trimCount, sorted.length - trimCount) : sorted;
      const sum = trimmed.reduce((a, b) => a + b, 0);
      return Math.round(sum / trimmed.length);
    }

    function updateRepMetricBuffer(scoreResult) {
      const isTimeBased = repCounter?.pattern?.isTimeBased;
      if (isTimeBased) return;

      const isRepInProgress = repCounter?.isInProgress ? repCounter.isInProgress() : false;
      if (isRepInProgress && !state.repInProgressPrev) {
        // rep ì‹œì‘ ì‹œ ë²„í¼ ë¦¬ì…‹
        state.repMetricBuffer = {};
      }
      state.repInProgressPrev = isRepInProgress;

      // rep ì§„í–‰ ì¤‘ + ACTIVE êµ¬ê°„ë§Œ ëˆ„ì  (ì˜¬ë¼ì˜¤ëŠ” TRANSITIONì—ì„œ ì ìˆ˜ ê¸‰ë½í•˜ëŠ” ë¬¸ì œ ë°©ì§€)
      if (!isRepInProgress) return;
      if (repCounter?.currentState !== window.REP_STATES?.ACTIVE) return;

      if (!scoreResult?.breakdown || scoreResult.breakdown.length === 0) return;
      for (const item of scoreResult.breakdown) {
        const key = item.key;
        if (!key) continue;
        if (!state.repMetricBuffer[key]) {
          state.repMetricBuffer[key] = {
            metric_id: item.metric_id,
            key,
            title: item.title || key,
            maxScore: item.maxScore,
            scores: []
          };
        }
        state.repMetricBuffer[key].scores.push(item.score);
      }
    }

    function updateViewInfo(angles) {
      if (!viewInfoEl || !angles) return;

      const now = performance.now();
      if (now - state.lastViewInfoAt < 250) return; // DOM ì—…ë°ì´íŠ¸ ê³¼ë‹¤ ë°©ì§€
      state.lastViewInfoAt = now;

      const view = angles.view || 'UNKNOWN';
      const source = angles.angleSource || 'UNKNOWN';
      const text = `VIEW: ${view} / SRC: ${source}`;

      if (text !== state.lastViewInfoText) {
        state.lastViewInfoText = text;
        viewInfoEl.textContent = text;
      }
    }

    // íšŸìˆ˜ ì™„ë£Œ ì²˜ë¦¬
    function handleRepComplete(repRecord) {
      state.currentRep = repRecord.repNumber;
      repCountEl.textContent = state.currentRep;

      // ë§ˆì§€ë§‰ repì˜ ë©”íŠ¸ë¦­ ìš”ì•½ ì €ì¥ (ACTIVE êµ¬ê°„ ê¸°ì¤€)
      state.lastRepMetricSummary = Object.values(state.repMetricBuffer || {})
        .map(m => ({
          metric_id: m.metric_id,
          key: m.key,
          title: m.title,
          maxScore: m.maxScore,
          score: aggregateScores(m.scores)
        }))
        .sort((a, b) => (b.score / (b.maxScore || 1)) - (a.score / (a.maxScore || 1)));

      // ë²„í¼ì— ê¸°ë¡
      if (sessionBuffer) {
        sessionBuffer.addRep(repRecord);
      }

      // ë£¨í‹´ ëª¨ë“œ ì²´í¬
      if (workoutData.mode === 'ROUTINE' && workoutData.routine) {
        checkRoutineProgress();
      }

      // ì‹œê°ì  í”¼ë“œë°±
      showRepFeedback(repRecord);
    }

    // ì ìˆ˜ í‘œì‹œ ì—…ë°ì´íŠ¸
    function updateScoreDisplay(scoreResult) {
      const isTimeBased = repCounter?.pattern?.isTimeBased;
      const hasAnyRep = repCounter?.getCount ? repCounter.getCount() > 0 : false;
      const isRepInProgress = repCounter?.isInProgress ? repCounter.isInProgress() : false;

      // rep ê¸°ë°˜ ìš´ë™: ACTIVE êµ¬ê°„ ê¸°ë°˜ rep ì ìˆ˜ë¥¼ í‘œì‹œ (ì²« rep ì „ì—ëŠ” --)
      const displayScore = isTimeBased
        ? scoreResult.score
        : (hasAnyRep || isRepInProgress) && repCounter?.getCurrentRepScore
          ? repCounter.getCurrentRepScore()
          : 0;

      state.liveScore = displayScore;
      liveScoreEl.textContent = (!isTimeBased && !hasAnyRep && !isRepInProgress) ? '--' : displayScore;

      // ì ìˆ˜ì— ë”°ë¥¸ ìƒ‰ìƒ
      liveScoreEl.style.background = 'none';
      liveScoreEl.style.webkitBackgroundClip = 'unset';
      liveScoreEl.style.webkitTextFillColor = 'unset';

      if (displayScore >= 80) {
        liveScoreEl.style.color = '#22c55e';
      } else if (displayScore >= 60) {
        liveScoreEl.style.color = '#eab308';
      } else if (displayScore > 0) {
        liveScoreEl.style.color = '#ef4444';
      } else {
        liveScoreEl.style.color = '#94a3b8';
      }

      // ì„¸ë¶€ ì ìˆ˜ í‘œì‹œ
      const shouldShowBreakdown = isTimeBased
        ? (scoreResult.breakdown && scoreResult.breakdown.length > 0)
        : ((isRepInProgress && Object.keys(state.repMetricBuffer || {}).length > 0) ||
          (!isRepInProgress && hasAnyRep && (state.lastRepMetricSummary?.length > 0)));

      if (shouldShowBreakdown) {
        const items = isTimeBased
          ? scoreResult.breakdown
          : (isRepInProgress
            ? Object.values(state.repMetricBuffer).map(m => ({
              key: m.key,
              title: m.title,
              score: aggregateScores(m.scores),
              maxScore: m.maxScore
            }))
            : state.lastRepMetricSummary);

        scoreBreakdownEl.innerHTML = items
          .filter(it => it && it.maxScore != null)
          .sort((a, b) => (b.score / (b.maxScore || 1)) - (a.score / (a.maxScore || 1)))
          .slice(0, 3) // ìƒìœ„ 3ê°œë§Œ í‘œì‹œ
          .map(item => `
          <div class="score-item">
            <span>${item.title || item.key}</span>
            <span>${Math.round(item.score)}/${item.maxScore}</span>
          </div>
        `).join('');
      } else if (scoreResult.score === 0) {
        scoreBreakdownEl.innerHTML = '<div class="score-item"><span class="muted">í¬ì¦ˆ ê°ì§€ ì¤‘...</span></div>';
      } else if (!isTimeBased && !isRepInProgress) {
        scoreBreakdownEl.innerHTML = '<div class="score-item"><span class="muted">rep ì‹œì‘í•˜ë©´ í‘œì‹œë©ë‹ˆë‹¤</span></div>';
      }
    }

    // í”¼ë“œë°± ì²´í¬
    function checkFeedback(scoreResult) {
      if (state.alertCooldown) return;

      // ì ìˆ˜ê°€ ë‚®ì€ í•­ëª© ì°¾ê¸°
      const lowScoreItem = scoreResult.breakdown?.find(
        item => item.feedback && item.score < item.maxScore * 0.6
      );

      if (lowScoreItem) {
        showAlert('ìì„¸ êµì • í•„ìš”', lowScoreItem.feedback);
      }
    }

    // íšŸìˆ˜ ì™„ë£Œ í”¼ë“œë°±
    function showRepFeedback(repRecord) {
      const msg = repRecord.score >= 80 ? 'ì™„ë²½í•´ìš”! ğŸ‘' :
        repRecord.score >= 60 ? 'ì¢‹ì•„ìš”! ğŸ‘' : 'ê³„ì† í•´ë³´ì„¸ìš”!';

      // ì ê¹ í‘œì‹œë˜ëŠ” í† ìŠ¤íŠ¸ ë©”ì‹œì§€
      showToast(`${repRecord.repNumber}íšŒ ${msg}`);
    }

    // í† ìŠ¤íŠ¸ ë©”ì‹œì§€
    function showToast(message) {
      const toast = document.createElement('div');
      toast.className = 'toast';
      toast.textContent = message;
      toast.style.cssText = `
      position: fixed;
      bottom: 100px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 12px 24px;
      border-radius: 8px;
      z-index: 1000;
      animation: fadeInOut 2s ease;
    `;
      document.body.appendChild(toast);
      setTimeout(() => toast.remove(), 2000);
    }

    // ë£¨í‹´ ì§„í–‰ë„ ì²´í¬
    function checkRoutineProgress() {
      const currentStep = workoutData.routine.routine_setup[state.currentStepIndex];
      if (!currentStep) return;

      // ëª©í‘œ íšŸìˆ˜ ë‹¬ì„±
      if (currentStep.target_type === 'REPS' && state.currentRep >= currentStep.target_value) {
        if (state.currentSet < currentStep.sets) {
          // ì„¸íŠ¸ ì™„ë£Œ, íœ´ì‹ ì‹œì‘
          if (sessionBuffer) {
            sessionBuffer.completeSet(currentStep.rest_sec);
          }
          startRest(currentStep.rest_sec);
        } else {
          // ë‹¤ìŒ ìš´ë™ìœ¼ë¡œ
          nextExercise();
        }
      }
    }

    // íƒ€ì´ë¨¸ ì‹œì‘
    function startTimer() {
      state.timerInterval = setInterval(() => {
        if (!state.isPaused && state.phase === 'WORKING') {
          state.totalTime++;
          updateTimerDisplay();
        }
      }, 1000);
    }

    // íƒ€ì´ë¨¸ í‘œì‹œ ì—…ë°ì´íŠ¸
    function updateTimerDisplay() {
      const mins = Math.floor(state.totalTime / 60);
      const secs = state.totalTime % 60;
      timerValueEl.textContent = `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
    }

    // ìƒíƒœ ì—…ë°ì´íŠ¸
    function updateStatus(className, text) {
      statusBadge.className = 'status ' + className;
      statusBadge.textContent = text;
    }

    // ì¼ì‹œì •ì§€ í† ê¸€
    function togglePause() {
      state.isPaused = !state.isPaused;

      if (state.isPaused) {
        state.phase = 'PAUSED';
        updateStatus('paused', 'ì¼ì‹œì •ì§€');
        pauseBtn.innerHTML = 'â–¶ï¸ ê³„ì†í•˜ê¸°';
        if (poseEngine) poseEngine.stop();
        if (sessionBuffer) sessionBuffer.addEvent('PAUSE');
      } else {
        state.phase = 'WORKING';
        updateStatus('running', 'ìš´ë™ ì¤‘');
        pauseBtn.innerHTML = 'â¸ï¸ ì¼ì‹œì •ì§€';
        if (poseEngine) poseEngine.start();
        if (sessionBuffer) sessionBuffer.addEvent('RESUME');
      }
    }

    // íœ´ì‹ ì‹œì‘
    function startRest(seconds) {
      state.phase = 'RESTING';
      state.restTimeLeft = seconds;
      updateStatus('rest', 'íœ´ì‹ ì¤‘');
      timerLabelEl.textContent = 'íœ´ì‹ ì‹œê°„';
      restTimerEl.hidden = false;
      restValueEl.textContent = seconds;

      if (poseEngine) poseEngine.stop();
      if (sessionBuffer) sessionBuffer.addEvent('REST_START', { duration: seconds });

      state.restInterval = setInterval(() => {
        if (!state.isPaused) {
          state.restTimeLeft--;
          restValueEl.textContent = state.restTimeLeft;

          if (state.restTimeLeft <= 0) {
            endRest();
          }
        }
      }, 1000);
    }

    // íœ´ì‹ ì¢…ë£Œ
    function endRest() {
      clearInterval(state.restInterval);
      restTimerEl.hidden = true;
      state.phase = 'WORKING';
      timerLabelEl.textContent = 'ìš´ë™ ì‹œê°„';
      updateStatus('running', 'ìš´ë™ ì¤‘');

      // ë‹¤ìŒ ì„¸íŠ¸ ì¤€ë¹„
      state.currentSet++;
      setCountEl.textContent = state.currentSet;
      state.currentRep = 0;
      repCountEl.textContent = 0;

      // RepCounter ë¦¬ì…‹ (íšŸìˆ˜ë§Œ)
      if (repCounter) {
        repCounter.repCount = 0;
      }

      if (poseEngine) poseEngine.start();
      if (sessionBuffer) sessionBuffer.addEvent('REST_END');

      showAlert('ë‹¤ìŒ ì„¸íŠ¸', `${state.currentSet}ì„¸íŠ¸ ì‹œì‘!`);
    }

    // ì•Œë¦¼ í‘œì‹œ
    function showAlert(title, message) {
      if (state.alertCooldown) return;

      alertTitle.textContent = title;
      alertMessage.textContent = message;
      alertContainer.hidden = false;

      state.alertCooldown = true;
      setTimeout(() => {
        alertContainer.hidden = true;
        state.alertCooldown = false;
      }, 3000);
    }

    // ë‹¤ìŒ ìš´ë™ìœ¼ë¡œ (ë£¨í‹´ ëª¨ë“œ)
    function nextExercise() {
      state.currentStepIndex++;
      const routineSteps = workoutData.routine.routine_setup;

      if (state.currentStepIndex >= routineSteps.length) {
        finishWorkout();
        return;
      }

      // ì§„í–‰ë¥  ì—…ë°ì´íŠ¸
      const progress = (state.currentStepIndex / routineSteps.length) * 100;
      document.getElementById('routineProgress').style.width = `${progress}%`;
      document.getElementById('routineStep').textContent =
        `${state.currentStepIndex + 1} / ${routineSteps.length} ìš´ë™`;

      // ìƒíƒœ ë¦¬ì…‹
      state.currentSet = 1;
      state.currentRep = 0;
      setCountEl.textContent = 1;
      repCountEl.textContent = 0;

      if (repCounter) repCounter.reset();
      if (sessionBuffer) sessionBuffer.addEvent('NEXT_EXERCISE', {
        stepIndex: state.currentStepIndex
      });

      showAlert('ë‹¤ìŒ ìš´ë™', routineSteps[state.currentStepIndex].exercise?.name || 'ë‹¤ìŒ ìš´ë™');
    }

    // ìš´ë™ ì¢…ë£Œ
    async function finishWorkout() {
      state.phase = 'FINISHED';

      // ë¦¬ì†ŒìŠ¤ ì •ë¦¬
      clearInterval(state.timerInterval);
      clearInterval(state.restInterval);
      if (state.frameLoop) {
        cancelAnimationFrame(state.frameLoop);
      }
      if (poseEngine) {
        poseEngine.destroy();
      }

      updateStatus('finished', 'ì™„ë£Œ');

      try {
        // ì„¸ì…˜ ë²„í¼ì—ì„œ ë°ì´í„° ì¶”ì¶œ
        const sessionData = sessionBuffer ? sessionBuffer.export() : {
          duration_sec: state.totalTime,
          total_reps: state.currentRep,
          final_score: state.liveScore || 0,
          summary_feedback: generateSummary()
        };

        // ì„¸ì…˜ ì¢…ë£Œ API í˜¸ì¶œ
        const response = await fetch(`/api/workout/session/${state.sessionId}/end`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(sessionData)
        });

        if (response.ok) {
          // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ ì •ë¦¬
          if (sessionBuffer) sessionBuffer.clearStorage();
          window.location.href = `/workout/result/${state.sessionId}`;
        } else {
          throw new Error('ì„¸ì…˜ ì¢…ë£Œ ì‹¤íŒ¨');
        }
      } catch (error) {
        console.error('[Session] ì¢…ë£Œ ì—ëŸ¬:', error);
        // ì‹¤íŒ¨í•´ë„ ê²°ê³¼ í˜ì´ì§€ë¡œ ì´ë™ ì‹œë„
        window.location.href = `/workout/result/${state.sessionId}`;
      }
    }

    // ìš”ì•½ ìƒì„± (fallback)
    function generateSummary() {
      if (state.liveScore >= 80) {
        return 'í›Œë¥­í•´ìš”! ìì„¸ê°€ ë§¤ìš° ì¢‹ìŠµë‹ˆë‹¤.';
      } else if (state.liveScore >= 60) {
        return 'ì¢‹ì•„ìš”! ì¡°ê¸ˆë§Œ ë” ì‹ ê²½ì“°ë©´ ì™„ë²½í•´ìš”.';
      } else {
        return 'ìì„¸ êµì •ì´ í•„ìš”í•©ë‹ˆë‹¤. ìš´ë™ ë°°ìš°ê¸°ë¥¼ í™•ì¸í•´ë³´ì„¸ìš”.';
      }
    }

    // ì¢…ë£Œ í™•ì¸
    function confirmExit() {
      if (state.phase === 'PREPARING') {
        window.location.href = workoutData.mode === 'ROUTINE' ? '/routine' : '/workout/free';
      } else {
        document.getElementById('exitModal').hidden = false;
      }
    }

    function closeExitModal() {
      document.getElementById('exitModal').hidden = true;
    }

    function forceExit() {
      finishWorkout();
    }

    // í˜ì´ì§€ ì–¸ë¡œë“œ ì‹œ ì •ë¦¬
    window.addEventListener('beforeunload', (e) => {
      if (state.phase === 'WORKING' || state.phase === 'RESTING' || state.phase === 'PAUSED') {
        // ë°ì´í„° ë°±ì—…
        if (sessionBuffer) sessionBuffer.saveToStorage();
        e.preventDefault();
        e.returnValue = '';
      }
    });

    // ì´ˆê¸°í™”
    document.addEventListener('DOMContentLoaded', () => {
      initCamera();
    });
  </script>

  <style>
    @keyframes fadeInOut {
      0% {
        opacity: 0;
        transform: translateX(-50%) translateY(20px);
      }

      15% {
        opacity: 1;
        transform: translateX(-50%) translateY(0);
      }

      85% {
        opacity: 1;
        transform: translateX(-50%) translateY(0);
      }

      100% {
        opacity: 0;
        transform: translateX(-50%) translateY(-20px);
      }
    }

    #poseCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    .score-item {
      display: flex;
      justify-content: space-between;
      padding: 6px 10px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 6px;
      font-size: 12px;
      margin-top: 4px;
    }
  </style>
